



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="../images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="绯色鱼的博客" href="https://colsons.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="绯色鱼的博客" href="https://colsons.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="绯色鱼的博客" href="https://colsons.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="../css/app.css?v=0.2.5">

  
  <meta name="keywords" content="数据结构,C++" />


<link rel="canonical" href="https://colsons.github.io/archives/1cad76d6.html">



  <title>
考研之数据结构编程笔记 - 编程 |
Lab Chen = 绯色鱼的博客</title>
<meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">考研之数据结构编程笔记
  </h1>
  
<div class="meta">
  <span class="item" title="Created: 2021-06-05 21:53:38">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">Posted on</span>
    <time itemprop="dateCreated datePublished" datetime="2021-06-05T21:53:38+08:00">2021-06-05</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Lab Chen</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclxfdlttj20zk0m8npd.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giciukx8a7j20zk0m8aio.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclflwv2aj20zk0m84qp.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclhfehz7j20zk0m8u0x.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclh0m9pdj20zk0m8hdt.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giph4baakhj20zk0m8h5q.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="../index.html">Home</a></span><i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="../categories/%E7%BC%96%E7%A8%8B/" itemprop="item" rel="index" title="In 编程"><span itemprop="name">编程</span></a>
<meta itemprop="position" content="1" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="https://colsons.github.io/archives/1cad76d6.html">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="../images/avatar.jpg">
    <meta itemprop="name" content="绯色鱼">
    <meta itemprop="description" content=", ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="绯色鱼的博客">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <p>记录考研生活</p>
<p><span id="more"></span></p>
<p>学习王道考研</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWI3NDExTjc5OD9wPTgmYW1wO3NwbV9pZF9mcm9tPXBhZ2VEcml2ZXI=">https://www.bilibili.com/video/BV1b7411N798?p=8&amp;spm_id_from=pageDriver</span></p>
<p>使用编程工具菜鸟编程在线 C++</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jLnJ1bm9vYi5jb20vY29tcGlsZS8xMg==">https://c.runoob.com/compile/12</span></p>
<h4 id="1-输出元素大小int为4b"><a class="anchor" href="#1-输出元素大小int为4b">#</a> 1、输出元素大小，int 为 4B</h4>
<pre class=" language-language-c++"><code class="language-language-c++">#include <iostream>
using namespace std;

typedef struct &#123;
	int num;
	int people;
&#125; Customer;

int main()
&#123;
	int num;
	printf("%d\n", sizeof(num));
	printf("%d", sizeof(Customer));
	return 0;
&#125;;
</code></pre>
<h4 id="2-顺序表的初始化"><a class="anchor" href="#2-顺序表的初始化">#</a> 2、顺序表的初始化</h4>
<pre class=" language-language-c++"><code class="language-language-c++">#include <iostream>
using namespace std;

// 定义了一种新的数据类型叫做 SqList 由两个整数组成
typedef struct&#123;
	//此时从内存拨拉了10个地址过来，可能里面为0 也可能有其他脏数据
	int data[10];
	// 数据表当前长度，也就是10个地址用了几个
	int length;
&#125; SqList;

void InitList(SqList &L)&#123;
	//将10个地址中的数据初始化 都为0
	for(int i=0; i<10; i++)
		L.data[i]=0;
	//初始长度0
	L.length=0;
&#125;

int main()
&#123;
	//新建立L 类型为SqList
	SqList L;
	//初始化L
	InitList(L);
	//取出数据并打印，注意此时操作不正当，应该用GetElem()，因为你不知道L的长度。
	//我们这里这样写，完全是因为 我们用的“上帝视角”
	for(int i=0; i<10; i++)
		printf("data[%d]=%d\n",i,L.data[i]);
	
	return 0;
&#125;;
</code></pre>
<h4 id="3-顺序表插入方法c实现"><a class="anchor" href="#3-顺序表插入方法c实现">#</a> 3、顺序表插入方法 C++ 实现</h4>
<p>（1）自己研究的，平均时间复杂度 O (n)，而且遇到了一些问题！【官方的平均复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\frac{n}{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span>】</p>
<p>PS：修正 下面问题貌似是连接两个表地址出的问题。</p>
<pre class=" language-language-c++"><code class="language-language-c++">#include <iostream>
using namespace std;


typedef struct&#123;
	int *data;
	//指示动态分配数组的指针
	int MaxSize;
	//顺序表的最大容量
	int length;
	//顺序表的当前长度
&#125;SeqList;

void InitList(SeqList &L)&#123;
	int InitSize = 10;
	//用malloc函数申请一片连续的存储空间
	L.data=(int *)malloc(InitSize*sizeof(int));
	L.length=0;
	L.MaxSize=InitSize;
&#125;

//自己改造的插入函数
void IncreaseSize(SeqList &L, int ind,int ad)&#123;
	int *p=L.data;
	//重新申请，这一行去掉之后发现只有下角标4 5变了 3210有的是脏数据有的0，
	//为什么？没查明白！
	//自己推导：p得到了L的复制品，然后从L[5]《-p[4]...一次给到3，也就是L[2]停止
	//然后L[ind=2]=ad，L角标0 1 不变 ，感觉推理没问题
	//实际：L[3]也换了，但是最后[0-3]又都变了
	//★暂时先记住必须要初始化，然后在...
	L.data=(int *)malloc((L.MaxSize+1)*sizeof(int));
	int i=L.length;
	for(i; i>ind; i--)&#123;
		L.data[i]=p[i-1]; //将数据复制到新区域
	&#125;
	for(i=0; i<ind;i++)&#123;
		L.data[i]=p[i];
	&#125;
	L.data[ind]=ad;
	L.MaxSize=L.MaxSize+1; //顺序表最大长度增加 len
	L.length = L.length+1;
	
	
	free(p);
	//释放原来的内存空间
&#125;

int main() &#123;
	SeqList L;
	//声明一个顺序表
	InitList(L);
	//初始化顺序表
	//往顺序表中随便插入几个元素....
	L.data[0]=1;
	L.data[1]=2;
	L.data[2]=3;
	L.data[3]=4;
	L.data[4]=5;
	L.length = 5;
	//取出数据并打印，注意此时操作不正当，应该用GetElem()，因为你不知道L的长度。
	//我们这里这样写，完全是因为 我们用的“上帝视角”
	for(int i=0; i<10; i++)
		printf("data[%d]=%d\n",i,L.data[i]);
	//在次序为3（下角标2）的位置插入5
	IncreaseSize(L,2,5);
	//取出数据并打印，注意此时操作不正当，应该用GetElem()，因为你不知道L的长度。
	//我们这里这样写，完全是因为 我们用的“上帝视角”
	for(int i=0; i<11; i++)
		printf("data[%d]=%d\n",i,L.data[i]);
	return 0;
&#125;


</code></pre>
<p>（2）正解，(看这个洗洗眼睛，发现自己写的太乱了，感觉就是在硬写，不在状态)</p>
<p>如果为了增加代码的健壮性，可以考虑插入函数中加一些判断，比如表满了不能插入，只有 5 个元素却要插入第 8 个位置，这种首先开始就是错的，要先辨别出来，给出反馈。</p>
<pre class=" language-language-c++"><code class="language-language-c++">#include <iostream>
using namespace std;


typedef struct&#123;
	int data[10];
	int length;
&#125;SqList;

void InitList(SqList &L)&#123;
	//将10个地址中的数据初始化 都为0
	for(int i=0; i<10; i++)
		L.data[i]=0;
	L.length=0;
&#125;

void ListInsert(SqList &L, int i,int e)&#123;
    //不用建新表根本，傻了傻了
	for(int j=L.length; j>i; j--)
		L.data[j]=L.data[j-1];
	L.data[i]=e;
	L.length++;
&#125;

int main() &#123;
	SqList L;
	//声明一个顺序表
	InitList(L);
	//初始化顺序表
	//往顺序表中随便插入几个元素....
	L.data[0]=1;
	L.data[1]=2;
	L.data[2]=3;
	L.data[3]=4;
	L.data[4]=5;
	L.length = 5;
	//取出数据并打印，注意此时操作不正当，应该用GetElem()，因为你不知道L的长度。
	//我们这里这样写，完全是因为 我们用的“上帝视角”
	for(int i=0; i<10; i++)
		printf("data[%d]=%d\n",i,L.data[i]);
	//在次序为3（下角标2）的位置插入5
	ListInsert(L,2,5);
	//取出数据并打印，注意此时操作不正当，应该用GetElem()，因为你不知道L的长度。
	//我们这里这样写，完全是因为 我们用的“上帝视角”
	for(int i=0; i<10; i++)
		printf("data[%d]=%d\n",i,L.data[i]);
	return 0;
&#125;
</code></pre>
<h4 id="4-顺序表删除方法c实现"><a class="anchor" href="#4-顺序表删除方法c实现">#</a> 4、顺序表删除方法 C++ 实现</h4>
<pre class=" language-language-c++"><code class="language-language-c++">#include <iostream>
using namespace std;


typedef struct&#123;
	int data[10];
	int length;
&#125;SqList;

void InitList(SqList &L)&#123;
	//将10个地址中的数据初始化 都为0
	for(int i=0; i<10; i++)
		L.data[i]=0;
	L.length=0;
&#125;

bool ListDelete(SqList &L, int i,int &e)&#123;
	//判断i的范围是否有效
	if(i<1 || i>L.length)
		return false;
	e = L.data[i-1];       //将被删除的元素赋值给e
	for(int j=i;j<L.length;j++) //将第i个位置后的元素移动
		L.data[j-1]=L.data[j];
	L.length--;
	//线性表长度减1
	return true;
&#125;


int main() &#123;
	SqList L;
	//声明一个顺序表
	InitList(L);
	//初始化顺序表
	//往顺序表中随便插入几个元素....
	L.data[0]=1;
	L.data[1]=2;
	L.data[2]=3;
	L.data[3]=4;
	L.data[4]=5;
	L.length = 5;
	//取出数据并打印，注意此时操作不正当，应该用GetElem()，因为你不知道L的长度。
	//我们这里这样写，完全是因为 我们用的“上帝视角”
	for(int i=0; i<10; i++)
		printf("data[%d]=%d\n",i,L.data[i]);
	//变量e将删除的元素返回
	int e = -1;
	// 下面一定要有外层括号！！！
	if (ListDelete(L,3,e))
		printf("已删除第3个元素,删除元素值为=%d\n",e);
	else
		printf("位序i不合法，删除失败\n");
	//取出数据并打印，注意此时操作不正当，应该用GetElem()，因为你不知道L的长度。
	//我们这里这样写，完全是因为 我们用的“上帝视角”
	for(int i=0; i<10; i++)
		printf("data[%d]=%d\n",i,L.data[i]);
	return 0;
&#125;
</code></pre>
<h4 id="5-单链表插入方法c实现带头节点位序插入"><a class="anchor" href="#5-单链表插入方法c实现带头节点位序插入">#</a> 5、单链表插入方法 C++ 实现 (带头节点位序插入)</h4>
<pre class=" language-language-c++"><code class="language-language-c++">#include <iostream>

using namespace std;

typedef struct LNode &#123;
    // 数据为int类型
    int data;
    // 指向后一个元素的指针
    struct LNode *next;
&#125; LNode, *LinkList;  // 两个名字

// 初始化单链表
bool InitList(LinkList &L) &#123;
    //分配一个头结点
    L = (LNode *) malloc(sizeof(LNode));
    if (L == NULL)
        return false;
    L->next = NULL;
    return true;
&#125;

bool ListInsert(LinkList &L, int i, int e) &#123;
    //最低插入为1，小于1报错
    if (i < 1)
        return false;
    //定义一个头指针 名字为p2
    LNode *p2;
    int j = 0;
    p2 = L;
    while (p2 != NULL && j < i - 1) &#123;
        p2 = p2->next;
        j++;
    &#125;
    if (p2 == NULL)
        return false;
    // 申请一个空位内存地址存储e，然后只需要连接前后两地址即可
    LNode *s = (LNode *) malloc(sizeof(LNode));
    s->data = e;
    s->next = p2->next;
    p2->next = s;
    return true;
&#125;

int main() &#123;
    LinkList L;

    //声明一个单链表
    InitList(L);

    //向表中添加一部分初始元素
    ListInsert(L, 1, 1);
    ListInsert(L, 2, 2);
    ListInsert(L, 3, 3);
    ListInsert(L, 4, 4);
    ListInsert(L, 5, 5);
    //查看表中元素 从0 开始 第一个为NULL 在物理地址中实际存在的是一个脏数据
    LNode *p3;
    p3 = L;
    for (int i = 0; i < 6; i++) &#123;
        cout << p3->data << endl;
        p3 = p3->next;
    &#125;
    //目前链表L = 1 2 3 4 5
    // 插入函数测试
    ListInsert(L, 3, 9);

    p3 = L;
    for (int i = 0; i < 7; i++) &#123;
        cout << p3->data << endl;
        p3 = p3->next;
    &#125;

&#125;
</code></pre>
<h4 id="6-单链表插入方法c实现不带头节点位序插入"><a class="anchor" href="#6-单链表插入方法c实现不带头节点位序插入">#</a> 6、单链表插入方法 C++ 实现 (不带头节点位序插入)</h4>
<pre class=" language-language-c++"><code class="language-language-c++">#include <iostream>

using namespace std;

typedef struct LNode &#123;
    // 数据为int类型
    int data;
    // 指向后一个元素的指针
    struct LNode *next;
&#125; LNode, *LinkList;  // 两个名字

// 初始化单链表
bool InitList(LinkList &L) &#123;
    //分配一个头结点
    L = (LNode *) malloc(sizeof(LNode));
    if (L == NULL)
        return false;
    L->next = NULL;
    return true;
&#125;

bool ListInsert(LinkList &L, int i, int e) &#123;
    //最低插入为1，小于1报错
    if (i < 1)
        return false;
    //因为没有头结点，如果处理位置发生在1处 需要单独考虑处理
    if (i==1)&#123;
        LNode *s = (LNode *)malloc(sizeof(LNode));
        // 定义一个LNode data为e  下一个指向原第一个LNode，然后让第一个重命名为L
        s->data=e;
        s->next=L;
        L=s;
        return true;
    &#125;

    //定义一个头指针 名字为p2
    LNode *p2;
    int j = 0;
    p2 = L;
    //因为没有头结点了 所以少一次循环
    while (p2 != NULL && j < i - 2) &#123;
        p2 = p2->next;
        j++;
    &#125;
    if (p2 == NULL)
        return false;
    // 申请一个空位内存地址存储e，然后只需要连接前后两地址即可
    LNode *s = (LNode *) malloc(sizeof(LNode));
    s->data = e;
    s->next = p2->next;
    p2->next = s;
    return true;
&#125;

int main() &#123;
    LinkList L;

    //声明一个单链表
    InitList(L);

    //向表中添加一部分初始元素
    ListInsert(L, 1, 1);
    ListInsert(L, 2, 2);
    ListInsert(L, 3, 3);
    ListInsert(L, 4, 4);
    ListInsert(L, 5, 5);
    //查看表中元素 从0 开始 第一个为NULL 在物理地址中实际存在的是一个脏数据
    LNode *p3;
    p3 = L;
    for (int i = 0; i < 5; i++) &#123;
        cout << p3->data << endl;
        p3 = p3->next;
    &#125;
    printf("======\n");
    //目前链表L = 1 2 3 4 5
    // 插入函数测试
    ListInsert(L, 3, 9);

    p3 = L;
    for (int i = 0; i < 6; i++) &#123;
        cout << p3->data << endl;
        p3 = p3->next;
    &#125;

&#125;
</code></pre>
<h4 id="7-单链表插入方法c实现指定节点后续插入"><a class="anchor" href="#7-单链表插入方法c实现指定节点后续插入">#</a> 7、单链表插入方法 C++ 实现 (指定节点后续插入)</h4>
<p>一般单链表默认有节点，因为多一个头结点 只有好处几乎没有坏处。（为啥不加？）</p>
<pre class=" language-language-c++"><code class="language-language-c++">#include <iostream>

using namespace std;

typedef struct LNode &#123;
    // 数据为int类型
    int data;
    // 指向后一个元素的指针
    struct LNode *next;
&#125; LNode, *LinkList;  // 两个名字

// 初始化单链表
bool InitList(LinkList &L) &#123;
    //分配一个头结点
    L = (LNode *) malloc(sizeof(LNode));
    if (L == NULL)
        return false;
    L->next = NULL;
    return true;
&#125;

bool ListInsert(LinkList &L, int i, int e) &#123;
    //最低插入为1，小于1报错
    if (i < 1)
        return false;
    //定义一个头指针 名字为p2
    LNode *p2;
    int j = 0;
    p2 = L;
    while (p2 != NULL && j < i - 1) &#123;
        p2 = p2->next;
        j++;
    &#125;
    if (p2 == NULL)
        return false;
    // 申请一个空位内存地址存储e，然后只需要连接前后两地址即可
    LNode *s = (LNode *) malloc(sizeof(LNode));
    s->data = e;
    s->next = p2->next;
    p2->next = s;
    return true;
&#125;

bool InsertNextNode(LNode *p, int e) &#123;
    //如果插入的p为空 返回错误
    if (p == NULL)
        return false;

    LNode *s = (LNode *) malloc(sizeof(LNode));
    if (s == NULL)
        return false;
    //投机取巧 按道理后插不好实现
    //这里 定义一个LNode data为e  下一个指向p的下一个 再将p的下一个指向定义的s
    s->data = e;
    s->next = p->next;
    p->next = s;
    return true;
&#125;

int main() &#123;
    LinkList L;

    //声明一个单链表
    InitList(L);

    //向表中添加一部分初始元素
    ListInsert(L, 1, 1);
    ListInsert(L, 2, 2);
    ListInsert(L, 3, 3);
    ListInsert(L, 4, 4);
    ListInsert(L, 5, 5);
    //查看表中元素 从0 开始 第一个为NULL 在物理地址中实际存在的是一个脏数据
    LNode *p3;
    p3 = L;
    for (int i = 0; i < 6; i++) &#123;
        cout << p3->data << endl;
        p3 = p3->next;
    &#125;
    printf("======\n");
    //目前链表L = 1 2 3 4 5
    // 插入函数测试
    InsertNextNode(L->next->next, 9);

    p3 = L;
    for (int i = 0; i < 7; i++) &#123;
        cout << p3->data << endl;
        p3 = p3->next;
    &#125;

&#125;
</code></pre>
<h4 id="8-单链表删除方法c实现带头结点-按位序删除"><a class="anchor" href="#8-单链表删除方法c实现带头结点-按位序删除">#</a> 8、 单链表删除方法 C++ 实现 (带头结点 按位序删除)</h4>
<pre class=" language-language-c++"><code class="language-language-c++">#include <iostream>

using namespace std;

typedef struct LNode &#123;
    // 数据为int类型
    int data;
    // 指向后一个元素的指针
    struct LNode *next;
&#125; LNode, *LinkList;  // 两个名字

// 初始化单链表
bool InitList(LinkList &L) &#123;
    //分配一个头结点
    L = (LNode *) malloc(sizeof(LNode));
    if (L == NULL)
        return false;
    L->next = NULL;
    return true;
&#125;

bool ListInsert(LinkList &L, int i, int e) &#123;
    //最低插入为1，小于1报错
    if (i < 1)
        return false;
    //定义一个头指针 名字为p2
    LNode *p2;
    int j = 0;
    p2 = L;
    while (p2 != NULL && j < i - 1) &#123;
        p2 = p2->next;
        j++;
    &#125;
    if (p2 == NULL)
        return false;
    // 申请一个空位内存地址存储e，然后只需要连接前后两地址即可
    LNode *s = (LNode *) malloc(sizeof(LNode));
    s->data = e;
    s->next = p2->next;
    p2->next = s;
    return true;
&#125;

bool ListDelete(LinkList &L, int i, int &e) &#123;
    if (i < 1)
        return false;
    LNode *p;
    int j = 0;
    p = L;
    while (p != NULL && j < i - 1) &#123;
        p = p->next;
        j++;
    &#125;
    if (p == NULL)
        return false;
    if (p->next == NULL)
        return false;
    LNode *q = p->next;
    e = q->data;
    p->next = q->next;
    free(q);
    return true;

&#125;

int main() &#123;
    LinkList L;

    //声明一个单链表
    InitList(L);

    //向表中添加一部分初始元素
    ListInsert(L, 1, 1);
    ListInsert(L, 2, 2);
    ListInsert(L, 3, 3);
    ListInsert(L, 4, 4);
    ListInsert(L, 5, 5);
    //查看表中元素 从0 开始 第一个为NULL 在物理地址中实际存在的是一个脏数据
    LNode *p3;
    p3 = L;
    for (int i = 0; i < 6; i++) &#123;
        cout << p3->data << endl;
        p3 = p3->next;
    &#125;
    printf("======\n");
    //目前链表L = 1 2 3 4 5
    // 删除函数测试
    int e;
    ListDelete(L, 2, e);

    p3 = L;
    for (int i = 0; i < 7; i++) &#123;
        cout << p3->data << endl;
        p3 = p3->next;
    &#125;

&#125;
</code></pre>
<h4 id="9-单链表删除方法c实现指定节点删除"><a class="anchor" href="#9-单链表删除方法c实现指定节点删除">#</a> 9、 单链表删除方法 C++ 实现 (指定节点删除)</h4>
<p>对于查找功能 (按位查找，按值查找)，在插入和删除中已经实现了，不再单独展示。</p>
<p>建议打包 GetElem 函数（得到某个链表 i 位置数据），方便维护。</p>
<pre class=" language-language-c++"><code class="language-language-c++">#include <iostream>

using namespace std;

typedef struct LNode &#123;
    // 数据为int类型
    int data;
    // 指向后一个元素的指针
    struct LNode *next;
&#125; LNode, *LinkList;  // 两个名字

// 初始化单链表
bool InitList(LinkList &L) &#123;
    //分配一个头结点
    L = (LNode *) malloc(sizeof(LNode));
    if (L == NULL)
        return false;
    L->next = NULL;
    return true;
&#125;

bool ListInsert(LinkList &L, int i, int e) &#123;
    //最低插入为1，小于1报错
    if (i < 1)
        return false;
    //定义一个头指针 名字为p2
    LNode *p2;
    int j = 0;
    p2 = L;
    while (p2 != NULL && j < i - 1) &#123;
        p2 = p2->next;
        j++;
    &#125;
    if (p2 == NULL)
        return false;
    // 申请一个空位内存地址存储e，然后只需要连接前后两地址即可
    LNode *s = (LNode *) malloc(sizeof(LNode));
    s->data = e;
    s->next = p2->next;
    p2->next = s;
    return true;
&#125;

bool DeleteNode(LNode *p) &#123;
    if (p == NULL)
        return false;
    LNode *q = p->next;
    p->data = p->next->data;
    p->next = q->next;
    free(q);
    return true;
&#125;

int main() &#123;
    LinkList L;

    //声明一个单链表
    InitList(L);

    //向表中添加一部分初始元素
    ListInsert(L, 1, 1);
    ListInsert(L, 2, 2);
    ListInsert(L, 3, 3);
    ListInsert(L, 4, 4);
    ListInsert(L, 5, 5);
    //查看表中元素 从0 开始 第一个为NULL 在物理地址中实际存在的是一个脏数据
    LNode *p3;
    p3 = L;
    for (int i = 0; i < 6; i++) &#123;
        cout << p3->data << endl;
        p3 = p3->next;
    &#125;
    printf("======\n");
    //目前链表L = 1 2 3 4 5
    // 删除函数测试
    DeleteNode(L->next->next);

    p3 = L;
    for (int i = 0; i < 7; i++) &#123;
        cout << p3->data << endl;
        p3 = p3->next;
    &#125;

&#125;
</code></pre>
<h4 id="10-向链表存入一段数据c实现"><a class="anchor" href="#10-向链表存入一段数据c实现">#</a> 10、 向链表存入一段数据 C++ 实现</h4>
<p>cin 函数为手动键盘输入方法</p>
<pre class=" language-language-c++"><code class="language-language-c++">#include <iostream>

using namespace std;

typedef struct LNode &#123;
    // 数据为int类型
    int data;
    // 指向后一个元素的指针
    struct LNode *next;
&#125; LNode, *LinkList;  // 两个名字

// 初始化单链表
bool InitList(LinkList &L) &#123;
    //分配一个头结点
    L = (LNode *) malloc(sizeof(LNode));
    if (L == NULL)
        return false;
    L->next = NULL;
    return true;
&#125;

LinkList List_TailInsert(LinkList &L)&#123;
    int x;
    cout<<"this is ";
    cin>>x;
    LNode *s,*r = L;
    while (x!=9999)&#123;
        s=(LNode *)malloc(sizeof(LNode));
        s->data=x;
        r->next=s;
        r=s;
        cout<<"this is ";
        cin>>x;
    &#125;
    r->next=NULL;
    return L;
&#125;


int main() &#123;
    //声明一个单链表
    LinkList L;

    //初始化单链表
    InitList(L);

    //向表中添加一部分初始元素
    List_TailInsert(L);

    //查看数据
    LNode *p3;
    p3 = L;
    for (int i = 1; i < 7; i++) &#123;
        cout << p3->data << endl;
        p3 = p3->next;
    &#125;

&#125;
</code></pre>

      <div class="tags">
          <a href="../tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"><i class="ic i-tag"></i> 数据结构</a>
          <a href="../tags/C/" rel="tag"><i class="ic i-tag"></i> C++</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2023-08-09 16:02:13" itemprop="dateModified" datetime="2023-08-09T16:02:13+08:00">2023-08-09</time>
  </span>
  <span id="archives/1cad76d6.html" class="item leancloud_visitors" data-flag-title="考研之数据结构编程笔记" title="Views">
      <span class="icon">
        <i class="ic i-eye"></i>
      </span>
      <span class="text">Views</span>
      <span class="leancloud-visitors-count"></span>
      <span class="text">times</span>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> Donate</button>
  <p>Give me a cup of [coffee]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="../images/wechatpay.png" alt="绯色鱼 WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div>
        <img data-src="../images/alipay.png" alt="绯色鱼 Alipay">
        <p>Alipay</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>Post author:  </strong>绯色鱼 <i class="ic i-at"><em>@</em></i>绯色鱼的博客
  </li>
  <li class="link">
    <strong>Post link: </strong>
    <a href="../https:/colsons.github.io/archives/1cad76d6.html" title="考研之数据结构编程笔记">https://colsons.github.io/archives/1cad76d6.html</a>
  </li>
  <li class="license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="a0e5a0c1.html" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipevuctzzj20zk0m84qp.jpg" title="Dos批处理pip安装库">
  <span class="type">Previous Post</span>
  <span class="category"><i class="ic i-flag"></i> 技巧</span>
  <h3>Dos批处理pip安装库</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="45098d0e.html" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipew28b65j20zk0m8hdt.jpg" title="遗传算法案例-货物派送Matlab&#x2F;Python">
  <span class="type">Next Post</span>
  <span class="category"><i class="ic i-flag"></i> 机器学习</span>
  <h3>遗传算法案例-货物派送Matlab/Python</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
          <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BE%93%E5%87%BA%E5%85%83%E7%B4%A0%E5%A4%A7%E5%B0%8Fint%E4%B8%BA4b"><span class="toc-number">1.</span> <span class="toc-text"> 1、输出元素大小，int 为 4B</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.</span> <span class="toc-text"> 2、顺序表的初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%8F%92%E5%85%A5%E6%96%B9%E6%B3%95c%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text"> 3、顺序表插入方法 C++ 实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%88%A0%E9%99%A4%E6%96%B9%E6%B3%95c%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text"> 4、顺序表删除方法 C++ 实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%96%B9%E6%B3%95c%E5%AE%9E%E7%8E%B0%E5%B8%A6%E5%A4%B4%E8%8A%82%E7%82%B9%E4%BD%8D%E5%BA%8F%E6%8F%92%E5%85%A5"><span class="toc-number">5.</span> <span class="toc-text"> 5、单链表插入方法 C++ 实现 (带头节点位序插入)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%96%B9%E6%B3%95c%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%B8%A6%E5%A4%B4%E8%8A%82%E7%82%B9%E4%BD%8D%E5%BA%8F%E6%8F%92%E5%85%A5"><span class="toc-number">6.</span> <span class="toc-text"> 6、单链表插入方法 C++ 实现 (不带头节点位序插入)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%96%B9%E6%B3%95c%E5%AE%9E%E7%8E%B0%E6%8C%87%E5%AE%9A%E8%8A%82%E7%82%B9%E5%90%8E%E7%BB%AD%E6%8F%92%E5%85%A5"><span class="toc-number">7.</span> <span class="toc-text"> 7、单链表插入方法 C++ 实现 (指定节点后续插入)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E6%96%B9%E6%B3%95c%E5%AE%9E%E7%8E%B0%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9-%E6%8C%89%E4%BD%8D%E5%BA%8F%E5%88%A0%E9%99%A4"><span class="toc-number">8.</span> <span class="toc-text"> 8、 单链表删除方法 C++ 实现 (带头结点 按位序删除)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E6%96%B9%E6%B3%95c%E5%AE%9E%E7%8E%B0%E6%8C%87%E5%AE%9A%E8%8A%82%E7%82%B9%E5%88%A0%E9%99%A4"><span class="toc-number">9.</span> <span class="toc-text"> 9、 单链表删除方法 C++ 实现 (指定节点删除)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E5%90%91%E9%93%BE%E8%A1%A8%E5%AD%98%E5%85%A5%E4%B8%80%E6%AE%B5%E6%95%B0%E6%8D%AEc%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.</span> <span class="toc-text"> 10、 向链表存入一段数据 C++ 实现</span></a></li></ol>
      </div>
      <div class="related panel pjax" data-title="Related">
        <ul>
          <li class="active"><a href="" rel="bookmark" title="考研之数据结构编程笔记">考研之数据结构编程笔记</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="绯色鱼"
      data-src="../images/avatar.jpg">
  <p class="name" itemprop="name">绯色鱼</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="../archives/">
        <span class="count">37</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="../categories/">
        <span class="count">11</span>
        <span class="name">categories</span>
      </a>
    </div>
    <div class="item tags">
      <a href="../tags/">
        <span class="count">31</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvbHNvbnM=" title="https:&#x2F;&#x2F;github.com&#x2F;colsons"><i class="ic i-github"></i></span>
      <span class="exturl item email" data-url="bWFpbHRvOjMzNTYwMTYzNjlAcXEuY29t" title="mailto:3356016369@qq.com"><i class="ic i-envelope"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="../index.html" rel="section"><i class="ic i-home"></i>首页</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>汇总</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="../categories/" rel="section"><i class="ic i-th"></i>分类</a>
  </li>

        
  <li class="item">
    <a href="../tags/" rel="section"><i class="ic i-tags"></i>标签</a>
  </li>

        
  <li class="item">
    <a href="../archives/" rel="section"><i class="ic i-list-alt"></i>归档</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="../friends/" rel="section"><i class="ic i-heart"></i>码友</a>
  </li>

    
  <li class="item">
    <a href="../links/" rel="section"><i class="ic i-magic"></i>链接</a>
  </li>

    
  <li class="item">
    <a href="../about/" rel="section"><i class="ic i-user"></i>关于</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="a0e5a0c1.html" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="45098d0e.html" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>Random Posts</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="../categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" title="In 机器学习">机器学习</a>
</div>

    <span><a href="ff107ac.html" title="Matlab-多元线性拟合-03">Matlab-多元线性拟合-03</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="../categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" title="In 机器学习">机器学习</a>
</div>

    <span><a href="45098d0e.html" title="遗传算法案例-货物派送Matlab&#x2F;Python">遗传算法案例-货物派送Matlab/Python</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="../categories/%E6%B5%8B%E8%AF%95/" title="In 测试">测试</a>
</div>

    <span><a href="4a17b156.html" title="测试文件">测试文件</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="../categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" title="In 机器学习">机器学习</a>
</div>

    <span><a href="bc5c2aae.html" title="聚类阶段整理（5）-系统聚类">聚类阶段整理（5）-系统聚类</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="../categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" title="In 计算机视觉">计算机视觉</a>
</div>

    <span><a href="9c9efd15.html" title="摄像头抓取保存帧成视频">摄像头抓取保存帧成视频</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="../categories/%E6%8A%80%E5%B7%A7/" title="In 技巧">技巧</a>
</div>

    <span><a href="92f60f59.html" title="Git远程无法clone仓库或者链接不到">Git远程无法clone仓库或者链接不到</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="../categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" title="In 机器学习">机器学习</a>
</div>

    <span><a href="9b594b83.html" title="Matlab-感知器-02">Matlab-感知器-02</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="../categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" title="In 机器学习">机器学习</a>
</div>

    <span><a href="b2f00d31.html" title="机器学习-模型评估与选择(上)-01">机器学习-模型评估与选择(上)-01</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="../categories/%E7%BC%96%E7%A8%8B/" title="In 编程">编程</a>
</div>

    <span><a href="" title="考研之数据结构编程笔记">考研之数据结构编程笔记</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="../categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" title="In 机器学习">机器学习</a>
</div>

    <span><a href="efc46ea5.html" title="一篇文章了解PCA,MDS的推导过程">一篇文章了解PCA,MDS的推导过程</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>Recent Comments</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">绯色鱼 @ Lab Chen</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: 'archives/1cad76d6.html',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,
    copyright: 'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="../js/app.js?v=0.2.5"></script>




</body>
</html>
